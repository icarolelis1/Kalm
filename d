[1mdiff --git a/Core/Graphics/CommandPool/CommandPool.cpp b/Core/Graphics/CommandPool/CommandPool.cpp[m
[1mindex a7c61ee..5dc0534 100644[m
[1m--- a/Core/Graphics/CommandPool/CommandPool.cpp[m
[1m+++ b/Core/Graphics/CommandPool/CommandPool.cpp[m
[36m@@ -18,23 +18,10 @@[m [mVK_Objects::CommandPool::CommandPool(const Device& _device, POOL_TYPE type, VkCo[m
 	if (result != VK_SUCCESS)std::cout << "Failed to create CommandPool\n";[m
 }[m
 [m
[31m-//VK_Objects::CommandPool::CommandPool(const CommandPool&other):device(other.device)[m
[31m-//{[m
[31m-//	std::cout << "TRYING TO COPY COMMANDPOOL\n";[m
[31m-//}[m
[31m-[m
[31m-//VK_Objects::CommandPool::CommandPool(CommandPool&&other):device(other.device),vk_cmdPool(other.vk_cmdPool)[m
[31m-//{[m
[31m-//	[m
[31m-//	other.vk_cmdPool = VK_NULL_HANDLE;[m
[31m-//	[m
[31m-//}[m
[31m-[m
[31m-[m
 std::unique_ptr<VK_Objects::CommandBuffer> VK_Objects::CommandPool::requestCommandBuffer(VkCommandBufferLevel level)const[m
 {[m
 [m
[31m-	std::unique_ptr<CommandBuffer> cmd = 	std::make_unique<VK_Objects::CommandBuffer>();[m
[32m+[m	[32mstd::unique_ptr<CommandBuffer> cmd = 	std::make_unique<VK_Objects::CommandBuffer>(level);[m
 [m
 	 allocateCommandBuffer(cmd->getCommandBufferHandle(), level);[m
 [m
[36m@@ -44,7 +31,7 @@[m [mstd::unique_ptr<VK_Objects::CommandBuffer> VK_Objects::CommandPool::requestComma[m
 [m
 VkCommandBuffer VK_Objects::CommandPool::requestCommandBufferVK(VkCommandBufferLevel level) const[m
 {[m
[31m-	std::unique_ptr<CommandBuffer> cmd = std::make_unique<VK_Objects::CommandBuffer>();[m
[32m+[m	[32mstd::unique_ptr<CommandBuffer> cmd = std::make_unique<VK_Objects::CommandBuffer>(level);[m
 [m
 	allocateCommandBuffer(cmd->getCommandBufferHandle(), level);[m
 [m
[36m@@ -82,29 +69,21 @@[m [mvoid VK_Objects::CommandPool::allocateCommandBuffer(VkCommandBuffer& cmdBuffer,[m
 	allocInfo.commandPool = vk_cmdPool;[m
 	allocInfo.level = level;[m
 	allocInfo.commandBufferCount = static_cast<uint32_t>(1);[m
[32m+[m	[32m//VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_[m
 [m
 	VkResult result = vkAllocateCommandBuffers(device.getLogicalDevice(), &allocInfo, &cmdBuffer);[m
[31m-[m
[31m-	if (result != VK_SUCCESS)[m
[31m-		std::cout << "    Failed to allocate CommandBuffer\n";[m
[32m+[m	[32mif (result != VK_SUCCESS)std::cout << "    Failed to allocate CommandBuffer\n";[m
 }[m
 [m
 VK_Objects::CommandPool::~CommandPool()[m
 {[m
[31m-[m
 	vkDestroyCommandPool(device.getLogicalDevice(), vk_cmdPool, nullptr);[m
[31m-[m
 }[m
 [m
[31m-[m
[31m-[m
[31m-VK_Objects::CommandBuffer::CommandBuffer()[m
[32m+[m[32mVK_Objects::CommandBuffer::CommandBuffer( VkCommandBufferLevel level)[m
 {[m
 }[m
 [m
[31m-[m
[31m-[m
[31m-[m
 VkCommandBuffer& VK_Objects::CommandBuffer::getCommandBufferHandle()[m
 {[m
 	// TODO: inserir instrução return aqui[m
[1mdiff --git a/Core/Graphics/CommandPool/CommandPool.h b/Core/Graphics/CommandPool/CommandPool.h[m
[1mindex f29008e..966ec14 100644[m
[1m--- a/Core/Graphics/CommandPool/CommandPool.h[m
[1m+++ b/Core/Graphics/CommandPool/CommandPool.h[m
[36m@@ -23,9 +23,7 @@[m [mnamespace VK_Objects {[m
 [m
 	public:[m
 [m
[31m-		CommandBuffer();[m
[31m-[m
[31m-[m
[32m+[m		[32mCommandBuffer(VkCommandBufferLevel);[m
 [m
 		VkCommandBuffer& getCommandBufferHandle();[m
 [m
[36m@@ -40,12 +38,11 @@[m [mnamespace VK_Objects {[m
 	public:[m
 [m
 		CommandPool(const Device& _device, POOL_TYPE type, VkCommandPoolCreateFlags  flags);[m
[31m-		CommandPool(const CommandPool&) =delete;[m
[31m-		CommandPool( CommandPool&&)=delete;[m
[31m-[m
[32m+[m[41m		[m
 		std::unique_ptr<VK_Objects::CommandBuffer> requestCommandBuffer(VkCommandBufferLevel level)const;[m
 		VkCommandBuffer requestCommandBufferVK(VkCommandBufferLevel level) const;[m
 [m
[32m+[m		[32mCommandPool(CommandPool&) = delete;[m
 [m
 		VkCommandPool& getPoolHanndle();[m
 [m
[1mdiff --git a/Core/Graphics/Cubemap/CubeMap.cpp b/Core/Graphics/Cubemap/CubeMap.cpp[m
[1mindex 01fad2e..0f7adf8 100644[m
[1m--- a/Core/Graphics/Cubemap/CubeMap.cpp[m
[1m+++ b/Core/Graphics/Cubemap/CubeMap.cpp[m
[36m@@ -74,7 +74,7 @@[m [mVK_Objects::PBuffer Vk_Functions::createCubeVertexBuffer(const VK_Objects::Devic[m
 	return std::move(vertexBuffer);[m
 }[m
 [m
[31m-void Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device* device, const char* hdriImagePath, VK_Objects::CubeMap& cubeMap, VK_Objects::CommandPool* transientPool, VK_Objects::CommandPool* graphicsPool, VK_Objects::SDescriptorPoolManager poolManager)[m
[32m+[m[32mvoid Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device* device, const char* hdriImagePath, VK_Objects::CubeMap& cubeMap, VK_Objects::CommandPool& transientPool, VK_Objects::CommandPool& graphicsPool, VK_Objects::SDescriptorPoolManager poolManager)[m
 {[m
 	int dim = 1080;[m
 [m
[36m@@ -105,13 +105,13 @@[m [mvoid Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device[m
 [m
 	//Image(const Device * device, uint32_t Width, uint32_t Height, ImageFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImageCreateFlags flags, VkImageAspectFlags aspectFlags, uint32_t arrayLayers = 1, bool useMaxNumMips = 0);[m
 [m
[31m-	Vk_Functions::setImageLayout(*device,*transientPool, cubeMap.getVkImageHandlee(), format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 6, 0);[m
[32m+[m	[32mVk_Functions::setImageLayout(*device, transientPool, cubeMap.getVkImageHandlee(), format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 6, 0);[m
 [m
 	VK_Objects::Image equirect(device, texWidth, texHeight, format, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, 0, VK_IMAGE_ASPECT_COLOR_BIT, 1, 0);[m
[31m-	Vk_Functions::setImageLayout(*device, *transientPool, equirect.getVkImageHandle(), format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, 0);[m
[32m+[m	[32mVk_Functions::setImageLayout(*device, transientPool, equirect.getVkImageHandle(), format, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, 0);[m
 	copyBufferToImage(stagingBuffer, equirect.getVkImageHandle(), *device, transientPool, texWidth, texHeight, 0, 1);[m
 [m
[31m-	Vk_Functions::setImageLayout(*device, *transientPool, equirect.getVkImageHandle(), format, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 1, 0);[m
[32m+[m	[32mVk_Functions::setImageLayout(*device, transientPool, equirect.getVkImageHandle(), format, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 1, 0);[m
 [m
 	//Create renderpass[m
 [m
[36m@@ -281,7 +281,7 @@[m [mvoid Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device[m
 	descriptorset.updateDescriptorset(0,imageInfo,false);[m
 	[m
 	VK_Objects::PBuffer vertexBuffer;[m
[31m-	vertexBuffer = createCubeVertexBuffer(device,transientPool);[m
[32m+[m	[32mvertexBuffer = createCubeVertexBuffer(device, &transientPool);[m
 [m
 	glm::mat4 captureProjection = glm::perspective(glm::radians(90.0f), 1.0f, 0.1f, 10.0f);[m
 	glm::mat4 captureViews[6] =[m
[36m@@ -312,7 +312,7 @@[m [mvoid Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device[m
 		renderPassInfo.clearValueCount = 1;[m
 		renderPassInfo.pClearValues = &clearValues;[m
 [m
[31m-		VK_Objects::CommandBuffer commandBuffer = *graphicsPool->requestCommandBuffer(VK_COMMAND_BUFFER_LEVEL_PRIMARY);[m
[32m+[m		[32mVK_Objects::CommandBuffer commandBuffer = *graphicsPool.requestCommandBuffer(VK_COMMAND_BUFFER_LEVEL_PRIMARY);[m
 		Vk_Functions::beginCommandBuffer(commandBuffer.getCommandBufferHandle());[m
 [m
 		vkCmdBeginRenderPass(commandBuffer.getCommandBufferHandle(), &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);[m
[36m@@ -361,11 +361,11 @@[m [mvoid Vk_Functions::convertEquirectangularImageToCubeMap(const VK_Objects::Device[m
 		submitInfo.pCommandBuffers = &comm